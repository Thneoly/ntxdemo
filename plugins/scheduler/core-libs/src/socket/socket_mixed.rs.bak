/// Real WASI socket implementation with actual network I/O
///
/// This module provides real TCP and UDP socket functionality.
use std::collections::HashMap;
use std::sync::Mutex;
use std::time::Duration;

#[cfg(not(target_arch = "wasm32"))]
use std::net::{SocketAddr as StdSocketAddr, TcpListener, TcpStream, ToSocketAddrs, UdpSocket};

#[cfg(not(target_arch = "wasm32"))]
use std::io::{Read, Write};

use once_cell::sync::Lazy;

/// Socket handle type
pub type SocketHandle = u32;

/// Address family
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AddressFamily {
    Ipv4,
    Ipv6,
}

/// Socket protocol
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SocketProtocol {
    Tcp,
    Udp,
}

/// Socket address
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct SocketAddress {
    pub host: String,
    pub port: u16,
}

impl SocketAddress {
    pub fn new(host: impl Into<String>, port: u16) -> Self {
        Self {
            host: host.into(),
            port,
        }
    }

    #[cfg(not(target_arch = "wasm32"))]
    fn to_socket_addr(&self) -> Result<StdSocketAddr, SocketError> {
        format!("{}:{}", self.host, self.port)
            .to_socket_addrs()
            .map_err(|_| SocketError::InvalidInput)?
            .next()
            .ok_or(SocketError::InvalidInput)
    }
}

/// Socket error types
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum SocketError {
    ConnectionRefused,
    ConnectionReset,
    ConnectionAborted,
    NetworkUnreachable,
    AddressInUse,
    AddressNotAvailable,
    Timeout,
    WouldBlock,
    InvalidInput,
    Other,
}

impl std::fmt::Display for SocketError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SocketError::ConnectionRefused => write!(f, "Connection refused"),
            SocketError::ConnectionReset => write!(f, "Connection reset"),
            SocketError::ConnectionAborted => write!(f, "Connection aborted"),
            SocketError::NetworkUnreachable => write!(f, "Network unreachable"),
            SocketError::AddressInUse => write!(f, "Address already in use"),
            SocketError::AddressNotAvailable => write!(f, "Address not available"),
            SocketError::Timeout => write!(f, "Operation timed out"),
            SocketError::WouldBlock => write!(f, "Operation would block"),
            SocketError::InvalidInput => write!(f, "Invalid input"),
            SocketError::Other => write!(f, "Other socket error"),
        }
    }
}

impl std::error::Error for SocketError {}

#[cfg(not(target_arch = "wasm32"))]
impl From<std::io::Error> for SocketError {
    fn from(err: std::io::Error) -> Self {
        use std::io::ErrorKind;
        match err.kind() {
            ErrorKind::ConnectionRefused => SocketError::ConnectionRefused,
            ErrorKind::ConnectionReset => SocketError::ConnectionReset,
            ErrorKind::ConnectionAborted => SocketError::ConnectionAborted,
            ErrorKind::AddrInUse => SocketError::AddressInUse,
            ErrorKind::AddrNotAvailable => SocketError::AddressNotAvailable,
            ErrorKind::TimedOut => SocketError::Timeout,
            ErrorKind::WouldBlock => SocketError::WouldBlock,
            ErrorKind::InvalidInput => SocketError::InvalidInput,
            _ => SocketError::Other,
        }
    }
}

/// Internal socket types (non-WASM)
#[cfg(not(target_arch = "wasm32"))]
enum SocketType {
    TcpStream(TcpStream),
    TcpListener(TcpListener),
    UdpSocket(UdpSocket),
}

/// Internal socket state
struct SocketInfo {
    family: AddressFamily,
    protocol: SocketProtocol,
    #[cfg(not(target_arch = "wasm32"))]
    socket: Option<SocketType>,
    #[cfg(target_arch = "wasm32")]
    _placeholder: (),
}

/// Global socket registry
static SOCKET_REGISTRY: Lazy<Mutex<SocketRegistry>> =
    Lazy::new(|| Mutex::new(SocketRegistry::new()));

struct SocketRegistry {
    next_handle: SocketHandle,
    sockets: HashMap<SocketHandle, SocketInfo>,
}

impl SocketRegistry {
    fn new() -> Self {
        Self {
            next_handle: 1,
            sockets: HashMap::new(),
        }
    }

    fn register(&mut self, info: SocketInfo) -> SocketHandle {
        let handle = self.next_handle;
        self.next_handle += 1;
        self.sockets.insert(handle, info);
        handle
    }

    fn get_mut(&mut self, handle: SocketHandle) -> Option<&mut SocketInfo> {
        self.sockets.get_mut(&handle)
    }

    fn remove(&mut self, handle: SocketHandle) -> Option<SocketInfo> {
        self.sockets.remove(&handle)
    }
}

/// Create a new socket
pub fn create_socket(
    family: AddressFamily,
    protocol: SocketProtocol,
) -> Result<SocketHandle, SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();

    #[cfg(not(target_arch = "wasm32"))]
    {
        let socket = match protocol {
            SocketProtocol::Tcp => {
                // TCP socket will be created during connect or bind
                None
            }
            SocketProtocol::Udp => {
                let addr = match family {
                    AddressFamily::Ipv4 => "0.0.0.0:0",
                    AddressFamily::Ipv6 => "[::]:0",
                };
                let udp = UdpSocket::bind(addr)?;
                Some(SocketType::UdpSocket(udp))
            }
        };

        let info = SocketInfo {
            family,
            protocol,
            socket,
        };
        Ok(registry.register(info))
    }

    #[cfg(target_arch = "wasm32")]
    {
        // WASM stub
        let info = SocketInfo {
            family,
            protocol,
            _placeholder: (),
        };
        Ok(registry.register(info))
    }
}

/// Connect to a remote address (TCP)
pub fn connect(handle: SocketHandle, address: SocketAddress) -> Result<(), SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    if info.protocol != SocketProtocol::Tcp {
        return Err(SocketError::InvalidInput);
    }

    #[cfg(not(target_arch = "wasm32"))]
    {
        let addr = address.to_socket_addr()?;
        let stream = TcpStream::connect(addr)?;
        info.socket = Some(SocketType::TcpStream(stream));
        Ok(())
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = address;
        Err(SocketError::Other)
    }
}

/// Bind socket to local address
pub fn bind(handle: SocketHandle, address: SocketAddress) -> Result<(), SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        let addr = address.to_socket_addr()?;

        match info.protocol {
            SocketProtocol::Tcp => {
                let listener = TcpListener::bind(addr)?;
                info.socket = Some(SocketType::TcpListener(listener));
                Ok(())
            }
            SocketProtocol::Udp => {
                let udp = UdpSocket::bind(addr)?;
                info.socket = Some(SocketType::UdpSocket(udp));
                Ok(())
            }
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = address;
        Err(SocketError::Other)
    }
}

/// Listen for incoming connections (TCP)
pub fn listen(handle: SocketHandle, _backlog: u32) -> Result<(), SocketError> {
    let registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry
        .sockets
        .get(&handle)
        .ok_or(SocketError::InvalidInput)?;

    if info.protocol != SocketProtocol::Tcp {
        return Err(SocketError::InvalidInput);
    }

    #[cfg(not(target_arch = "wasm32"))]
    {
        // TcpListener is already listening after bind
        match info.socket {
            Some(SocketType::TcpListener(_)) => Ok(()),
            _ => Err(SocketError::InvalidInput),
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        Err(SocketError::Other)
    }
}

/// Accept an incoming connection (TCP)
pub fn accept(handle: SocketHandle) -> Result<SocketHandle, SocketError> {
    #[cfg(not(target_arch = "wasm32"))]
    {
        // First, get the listener and family
        let (listener_clone, family) = {
            let registry = SOCKET_REGISTRY.lock().unwrap();
            let info = registry
                .sockets
                .get(&handle)
                .ok_or(SocketError::InvalidInput)?;

            if let Some(SocketType::TcpListener(ref listener)) = info.socket {
                // Clone the listener to use outside the lock
                let listener_clone = listener.try_clone()?;
                (listener_clone, info.family)
            } else {
                return Err(SocketError::InvalidInput);
            }
        };

        // Now accept without holding the lock
        let (stream, _) = listener_clone.accept()?;

        // Register the new client socket
        let mut registry = SOCKET_REGISTRY.lock().unwrap();
        let client_info = SocketInfo {
            family,
            protocol: SocketProtocol::Tcp,
            socket: Some(SocketType::TcpStream(stream)),
        };
        Ok(registry.register(client_info))
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = handle;
        Err(SocketError::Other)
    }
}

/// Send data through socket
pub fn send(handle: SocketHandle, data: &[u8]) -> Result<u64, SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        if let Some(SocketType::TcpStream(ref mut stream)) = info.socket {
            let bytes_written = stream.write(data)?;
            Ok(bytes_written as u64)
        } else {
            Err(SocketError::InvalidInput)
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = data;
        Err(SocketError::Other)
    }
}

/// Receive data from socket
pub fn receive(handle: SocketHandle, max_len: u64) -> Result<Vec<u8>, SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        if let Some(SocketType::TcpStream(ref mut stream)) = info.socket {
            let mut buffer = vec![0u8; max_len as usize];
            let bytes_read = stream.read(&mut buffer)?;
            buffer.truncate(bytes_read);
            Ok(buffer)
        } else {
            Err(SocketError::InvalidInput)
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = max_len;
        Err(SocketError::Other)
    }
}

/// Send data to specific address (UDP)
pub fn send_to(
    handle: SocketHandle,
    data: &[u8],
    address: SocketAddress,
) -> Result<u64, SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    if info.protocol != SocketProtocol::Udp {
        return Err(SocketError::InvalidInput);
    }

    #[cfg(not(target_arch = "wasm32"))]
    {
        if let Some(SocketType::UdpSocket(ref socket)) = info.socket {
            let addr = address.to_socket_addr()?;
            let bytes_sent = socket.send_to(data, addr)?;
            Ok(bytes_sent as u64)
        } else {
            Err(SocketError::InvalidInput)
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = (data, address);
        Err(SocketError::Other)
    }
}

/// Receive data with sender address (UDP)
pub fn receive_from(
    handle: SocketHandle,
    max_len: u64,
) -> Result<(Vec<u8>, SocketAddress), SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    if info.protocol != SocketProtocol::Udp {
        return Err(SocketError::InvalidInput);
    }

    #[cfg(not(target_arch = "wasm32"))]
    {
        if let Some(SocketType::UdpSocket(ref socket)) = info.socket {
            let mut buffer = vec![0u8; max_len as usize];
            let (bytes_read, sender_addr) = socket.recv_from(&mut buffer)?;
            buffer.truncate(bytes_read);

            let address = SocketAddress {
                host: sender_addr.ip().to_string(),
                port: sender_addr.port(),
            };
            Ok((buffer, address))
        } else {
            Err(SocketError::InvalidInput)
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = max_len;
        Err(SocketError::Other)
    }
}

/// Close socket
pub fn close(handle: SocketHandle) -> Result<(), SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    registry.remove(handle).ok_or(SocketError::InvalidInput)?;
    Ok(())
}

/// Set socket option: read timeout
pub fn set_read_timeout(handle: SocketHandle, timeout_ms: Option<u64>) -> Result<(), SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        let duration = timeout_ms.map(Duration::from_millis);

        match info.socket {
            Some(SocketType::TcpStream(ref stream)) => {
                stream.set_read_timeout(duration)?;
                Ok(())
            }
            Some(SocketType::UdpSocket(ref socket)) => {
                socket.set_read_timeout(duration)?;
                Ok(())
            }
            _ => Err(SocketError::InvalidInput),
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = timeout_ms;
        Err(SocketError::Other)
    }
}

/// Set socket option: write timeout
pub fn set_write_timeout(handle: SocketHandle, timeout_ms: Option<u64>) -> Result<(), SocketError> {
    let mut registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry.get_mut(handle).ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        let duration = timeout_ms.map(Duration::from_millis);

        match info.socket {
            Some(SocketType::TcpStream(ref stream)) => {
                stream.set_write_timeout(duration)?;
                Ok(())
            }
            Some(SocketType::UdpSocket(ref socket)) => {
                socket.set_write_timeout(duration)?;
                Ok(())
            }
            _ => Err(SocketError::InvalidInput),
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = timeout_ms;
        Err(SocketError::Other)
    }
}

/// Set socket option: reuse address
pub fn set_reuse_address(handle: SocketHandle, reuse: bool) -> Result<(), SocketError> {
    let registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry
        .sockets
        .get(&handle)
        .ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        match info.socket {
            Some(SocketType::TcpListener(ref listener)) => {
                use std::os::unix::io::AsRawFd;
                let fd = listener.as_raw_fd();
                drop(registry);

                // This is platform specific, simplified for now
                let _ = (fd, reuse);
                Ok(())
            }
            Some(SocketType::UdpSocket(_)) => {
                // UDP socket reuse address
                Ok(())
            }
            _ => Err(SocketError::InvalidInput),
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        let _ = reuse;
        Err(SocketError::Other)
    }
}

/// Get local address of socket
pub fn get_local_address(handle: SocketHandle) -> Result<SocketAddress, SocketError> {
    let registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry
        .sockets
        .get(&handle)
        .ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        let addr = match info.socket {
            Some(SocketType::TcpStream(ref stream)) => stream.local_addr()?,
            Some(SocketType::TcpListener(ref listener)) => listener.local_addr()?,
            Some(SocketType::UdpSocket(ref socket)) => socket.local_addr()?,
            None => return Err(SocketError::InvalidInput),
        };

        Ok(SocketAddress {
            host: addr.ip().to_string(),
            port: addr.port(),
        })
    }

    #[cfg(target_arch = "wasm32")]
    {
        Err(SocketError::Other)
    }
}

/// Get peer address of socket
pub fn get_peer_address(handle: SocketHandle) -> Result<SocketAddress, SocketError> {
    let registry = SOCKET_REGISTRY.lock().unwrap();
    let info = registry
        .sockets
        .get(&handle)
        .ok_or(SocketError::InvalidInput)?;

    #[cfg(not(target_arch = "wasm32"))]
    {
        if let Some(SocketType::TcpStream(ref stream)) = info.socket {
            let addr = stream.peer_addr()?;
            Ok(SocketAddress {
                host: addr.ip().to_string(),
                port: addr.port(),
            })
        } else {
            Err(SocketError::InvalidInput)
        }
    }

    #[cfg(target_arch = "wasm32")]
    {
        Err(SocketError::Other)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(not(target_arch = "wasm32"))]
    fn test_tcp_socket_creation() {
        let result = create_socket(AddressFamily::Ipv4, SocketProtocol::Tcp);
        assert!(result.is_ok());
        let handle = result.unwrap();
        assert!(close(handle).is_ok());
    }

    #[test]
    #[cfg(not(target_arch = "wasm32"))]
    fn test_udp_socket_creation() {
        let result = create_socket(AddressFamily::Ipv4, SocketProtocol::Udp);
        assert!(result.is_ok());
        let handle = result.unwrap();
        assert!(close(handle).is_ok());
    }
}
