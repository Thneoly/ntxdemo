package runner:progress;

interface types {
    /// Standardized workflow phases used across Runner components.
    enum progress-phase {
        initiating,
        planning,
        executing,
        monitoring,
        closing,
    }

    /// Structured field updates produced by Runner Core.
    record progress-field {
        section: string,
        key: string,
        value: string,
    }

    /// Scoped workbook identifier (user/task pair or broader aggregate).
    record scope {
        user-id: option<string>,
        task-id: option<string>,
        tenant: option<string>,
    }

    record rollback-point {
        name: string,
        timestamp-ns: u64,
    }

    enum progress-error-kind { transient, permanent, conflict }

    record progress-error {
        code: u32,
        kind: progress-error-kind,
        message: string,
    }

    record workbook-status {
        scope: scope,
        phase: progress-phase,
        progress: f32,
        updated-at-ns: u64,
        errors: list<progress-error>,
    }

    record update-patch {
        scope: scope,
        phase: option<progress-phase>,
        delta-progress: option<f32>,
        dirty-fields: list<progress-field>,
        correlation-id: option<string>,
    }

    record progress-update {
        scope: scope,
        phase: progress-phase,
        progress: f32,
        timestamp-ns: u64,
        dirty-fields: list<progress-field>,
        aggregation: option<f32>,
        error-class: option<string>,
        update-id: u64,
    }
}

interface workbook {
    use types.{scope, workbook-status, progress-error, update-patch, rollback-point};

    /// Obtain the current immutable snapshot for a workbook scope.
    get-status: func(scope: scope) -> result<workbook-status, progress-error>;

    /// Apply a partial update produced by Runner Core.
    update: func(patch: update-patch) -> result<workbook-status, progress-error>;

    /// Roll the workbook back to a named checkpoint.
    rollback: func(scope: scope, to: rollback-point) -> result<workbook-status, progress-error>;
}

interface events {
    use types.{scope, progress-error, progress-update};

    resource subscription {}

    /// Open a subscription stream filtered by scope (None = broadcast).
    subscribe: func(filter: option<scope>) -> result<subscription, progress-error>;

    /// Retrieve the next progress update, if available.
    recv: func(sub: borrow<subscription>) -> option<progress-update>;

    /// Provide readiness information for integration with async runtimes.
    ready: func(sub: borrow<subscription>) -> bool;

    /// Acknowledge completion so the bus can advance cursors.
    ack: func(sub: borrow<subscription>, update-id: u64);
}

interface telemetry {
    heartbeat: func(active-subscriptions: u32, queue-depth: u32, avg-latency-ms: f32);
    flush-metrics: func(snapshot-time-ns: u64);
}

world progress-runner {
    export workbook;
    export events;
    export telemetry;
}
